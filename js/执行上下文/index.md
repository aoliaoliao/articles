我们知道，当函数被执行的时候，JS引擎会创建一个该函数的**执行上下文（Context）**，该`Context`随即会被压入到**执行上下文栈**的顶部，JS引擎总是会执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出。

# 关于执行上下文

在JS中，执行上下文可以分为三种：
1. **全局执行上下文**： 这是一个基础的全局上下文，它永远在执行上下文栈的最底部。
2. **函数执行上下文**：当函数被执行的时候，会创建该函数的执行上下文，当创建完毕之后，会被压入到执行上下文栈中。
3.**eval函数执行上下文**：todo 

一个执行上下文可以理解为一个对象，该对象主要分为三个阶段：**创建阶段** --> **执行阶段** --> **回收阶段**。

上下文对象主要有三个属性：`变量对象（VO）`, `this`, `作用域链（scope chain）`。创建阶段也就是对这三个值进行声明，执行阶段主要是变量对象中的值进行赋值和执行函数语句，回收阶段主要是出栈操作，其中的无用对象会被垃圾回收机制销毁。


### 创建阶段

变量对象（Variable Object）是一个抽象概念，再具体的代码执行层面，我们并不能直接访问到它。为了便于说明，我们经常将他理解为一个对象，但事实上，VO的初始结构和具体实现并不一定如此。

变量对象的主要作用是记录上下文声明中的以下内容：**函数的形参arguments**, **变量variables**, **函数声明functionName**，

在创建阶段，形参，函数名，变量名都会作为VO的一个属性，当然因为是创建阶段，这些属性都不会有值，其值都为undefined。

 
作用域链也会在此阶段被初步创建记录，详细查看上一篇文章：[作用域和作用域链](../作用域和作用域链/index.md)

### 执行阶段
当函数被执行的时候，对应的`VO`会被激活，激活之后我们称之为**活动对象（AO）**。激活的表现有哪些？ 首先是arguments, 不单单是将传入确定的实参进行赋值，arguments还会进行其他的处理，比如，添加`callee`和`length`两个属性。然后，就是在代码的执行过程中，变量被一一赋值和修改。如果需要执行嵌套的函数，那就会进入另一个执行上下文的创建执行回收流程，这一点很好理解。

> 调用函数时，会为其创建一个Arguments对象，并自动初始化局部变量arguments，指代该Arguments对象。所有作为参数传入的值都会成为Arguments对象的数组元素。

正如在作用域那篇文章中讲到的，`AO`最终也会被加入作用域链，形成完整的作用域链。


this的指向：在全局执行上下文中，`this`的值指向全局对象。在函数执行上下文中，this取决于调用函数的方式，即this指向激活上下文代码的调用者 。

### 回收阶段

当函数执行完毕，对应的执行上下文对象会被从栈中弹出，然后会在适当的时候被垃圾回收机制回收。




