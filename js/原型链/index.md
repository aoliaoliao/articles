原型链是JS中一个极其重要的概念，对于理解JS中的继承，`new` 关键字，`Class`，组件和插件的编写，都有很重要的意义。

# 原型对象

要理解原型链，首先对**原型对象**有一个认识。正如该名词字面上表示的，这是一个对象，但这个对象不需要开发人员显示的声明创建，当我创建一个函数的时候，这个函数自动就拥有了一个原型对象。

## 几个基本概念和关系
为了方便理解，先统一列出几个概念

- 函数
- 函数的prototype属性
- 原型对象
- 原型对象的constrator属性（指向构造函数的指针）
- 实例对象
- 实例对象的内部属性[[Prototype]]

理清楚了这几个概念之间的关系，也就理解了原型对象，一图胜千言，上个图先：

![](./原型对象关系图.png)

上图中共有一个构造函数`Person`, 两个实例`person1`、 `person2`, 一个原型对象`Person Prototype`。 这是JS中对这三个实体的一个基础设计，至于为什么要这样设计，我们在后面将会看到。

当我们创建一个构造函数`Person`时，JS会为该构造函数创造一个属性`prototype`， 这个属性的值本质上是一个指针，指向构造函数对应的**原型对象**

当调用构造函数`Person`创造一个新的实例`person1`之后，该实例的内部将生成一个属性`[[Prototype]]`, 该属性的值是一个指针，指向构造函数Person对应的**原型对象**

当JS创造一个原型对象以后，所有的原型对象都自动获得一个属性`constructor`。这个属性的值也是一个指针，指向对应的构造函数。 在这里，原型对象没有一个显式的名称，当我们想要表示`Person`所对应的原型对象，我们就用`Person Prototype`来表示。当然，在具体使用的时候，你可以将原型对象显式的赋予一个变量。

> 只有函数对象才具有`prototype`属性
> 
> [[Prototype]]属性在浏览器中有被实现，其名称是`__proto__`， 而在其他实现中，这个属性是不可见的。

从上图我们可以看到，当实例`person1` 和 `person2`被创建之后，这两个实例其实和构造函数是没有直接联系的，它们只和构造函数的原型对象有关系。这也是多个实例可以共享原型对象中的属性和方法的基础。

当我们试图访问一个实例中的属性时，代码会执行一次搜索，搜索的关键字就是试图访问的属性的名称。搜索首先从实例对象本身开始，如果找到了则直接返回，不再继续搜索；如果没有找到，则继续搜索实例对象的属性`[[Prototype]]`所指向的值，也就是原型对象，如果在原型对象中找到了目标属性，就返回对应的值。


# 原型链

实现原型链的基本思想是更改构造函数的原型对象指向其父级的一个实例，也就是说其本质是重写了原型对象。

再次总结一下`构造函数``原型``实例`三者的关系：
- 每个构造函数都有一个原型对象
- 原型对象都包含一个指向构造函数的指针
- 实例都包含一个指向原型对象的内部指针

同样上个图说明一下：





