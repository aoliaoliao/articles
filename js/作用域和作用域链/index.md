
# 作用域的基础知识

我们都知道，当我们定义一个变量的时候，这个变量是有生命周期的，什么时候声明，什么时候销毁。描述这个变量可用性的范围的概念就是**作用域**。

一个基础知识是我们都知道现在JS中的作用域范围分为三种：`块级作用域，局部作用域，全局作用域`。

但作用域从另一个角度还可以分为`词法作用域，动态作用域`

**词法作用域**，也叫静态作用域，它的作用域是指在词法分析阶段，也就是在声明的时候就确定了，不会改变。

**动态作用域** 是在运行时根据程序的流程信息来动态确定的，而不是在写代码时进行静态确定的。

**JavaScript没有用动态作用域概念**，再JS的世界中，`this`的表现非常接近动态作用域，但首先this不是变量，而且this的值自由一套逻辑，后面会单写一篇文章探讨

```javascript
const str = 'global'

function foo() {
  return str
}

function bar() {
  const str = 'local'
  return foo()
}

bar() // global

```
这是网上一个经典的例子，用来说明js中的作用域属于词法作用域。当代码最终执行到`foo()`的时候，`foo()`方法内部没有变量`str`,那么根据作用域链的规则，则向上级查找，因为作用域是在声明的时候确定的，那么此时会向全局作用域中查找，找到`str = 'global'`,最终输出`global`。

如果假设JS是动态作用域呢，因为`foo()`方法是在`bar()`中进行调用的，作用域链的上游就变成了`bar()`方法所形成的局部作用域，找到`str='local'`, 最终会输出`local`。 当然，这个是理论推测，在JS中是没法验证了。

> JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 foo() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 foo()，这种绑定在执行 f() 时依然有效。


# 作用域链

什么是作用域链呢？按照上文JS中的作用域是**静态作用域**的说法，应该是函数在**声明**的时候，对函数中用到的变量一层一层的从内向外进行查找而形成的链条。

这样说其实不是很准确，这只包含了一部分。

我们想一下，作用域链这个概念设计出来的目的是什么？作用域链的最终目的是保证函数在**执行**的时候可以访问到其外层的变量和方法。函数在执行阶段其所处的环境肯定和声明的时候是有区别的，比如“入参”的变量就无法在声明的时候确定一条作用域链条。

那么准确的作用域链其实还是应该是以函数**执行**阶段查找的链条为主，按照《JavaScript深入之变量对象》中的说法:
>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从**父级**执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

这里最重要的就是这个父级的说法。这个父级指的是函数声明时候所形成的父级。

**也就是说函数在执行的时候维护了一套声明时候的作用域父级关系。**

### 具体怎么做的呢

当函数声明的时候，JS引擎会根据当前声明的位置为函数创建一个属性`[[scope]]`, 只要函数声明了，这个属性`[[scope]]`就会存在，和函数是否执行没有关系。

然后当函数被执行到的时候，JS引擎会生成函数的**执行上下文对象**, 这个对象中包括一个属性`scope`——这个函数最终的作用域链，这个`scope`和声明时候的`[[scope]]`有一点区别，`scope`中会包含当前函数的**活动对象AO**, 并且AO会处于作用域链的最前端。


### 举个例子
对上文举的例子稍微改变一下，也做个更深层的嵌套，方便更好的说明这个问题

```javascript
var x = 10; 
function foo() {
    var y = 20; 
    function bar() {
        var z = 30; 
        console.log(x + y + z);
    }; 
    bar() // 60
}; 
foo();

```
这个例子的执行上下文栈最多存在三个值：`barContext`,`fooContext`, `globalContext`，以最深层的`bar()`为例:

当`bar()`函数被声明的时候，创建函数的`[[scope]]`属性
```javascript
bar.[[scope]] = [
  fooContext.VO,
  globalContext.VO
]
```

当`bar()`函数被执行到的时候, 此时`bar()`的执行上下文对象`barContext`中`scope`属性的值是：

```javascript
barContext = {
  AO: {
    arguments: {
      length: 0
    },
    z: 30
  },
  scope: [
    AO, // bar函数的活动对象
    bar.[[scope]] // 以后再向上查询值就是在函数声明时确定的链条中进行查找啦。
  ]
}
```


















